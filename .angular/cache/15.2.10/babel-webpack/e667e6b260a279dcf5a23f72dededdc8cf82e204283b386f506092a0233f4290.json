{"ast":null,"code":"import _asyncToGenerator from \"/Users/jiss/Documents/Banco/shell-container/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nlet config = {};\nconst containerMap = {};\nconst remoteMap = {};\nlet isDefaultScopeInitialized = false;\nfunction lookupExposedModule(_x, _x2) {\n  return _lookupExposedModule.apply(this, arguments);\n}\nfunction _lookupExposedModule() {\n  _lookupExposedModule = _asyncToGenerator(function* (key, exposedModule) {\n    const container = containerMap[key];\n    const factory = yield container.get(exposedModule);\n    const Module = factory();\n    return Module;\n  });\n  return _lookupExposedModule.apply(this, arguments);\n}\nfunction initRemote(_x3, _x4) {\n  return _initRemote.apply(this, arguments);\n}\nfunction _initRemote() {\n  _initRemote = _asyncToGenerator(function* (container, key) {\n    // const container = window[key] as Container;\n    // Do we still need to initialize the remote?\n    if (remoteMap[key]) {\n      return container;\n    }\n    // Do we still need to initialize the share scope?\n    if (!isDefaultScopeInitialized) {\n      yield __webpack_init_sharing__('default');\n      isDefaultScopeInitialized = true;\n    }\n    yield container.init(__webpack_share_scopes__.default);\n    remoteMap[key] = true;\n    return container;\n  });\n  return _initRemote.apply(this, arguments);\n}\nfunction loadRemoteEntry(_x5, _x6) {\n  return _loadRemoteEntry.apply(this, arguments);\n}\nfunction _loadRemoteEntry() {\n  _loadRemoteEntry = _asyncToGenerator(function* (remoteEntryOrOptions, remoteName) {\n    if (typeof remoteEntryOrOptions === 'string') {\n      const remoteEntry = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(remoteEntry, remoteName);\n    } else if (remoteEntryOrOptions.type === 'script') {\n      const options = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\n    } else if (remoteEntryOrOptions.type === 'module') {\n      const options = remoteEntryOrOptions;\n      yield loadRemoteModuleEntry(options.remoteEntry);\n    }\n  });\n  return _loadRemoteEntry.apply(this, arguments);\n}\nfunction loadRemoteModuleEntry(_x7) {\n  return _loadRemoteModuleEntry.apply(this, arguments);\n}\nfunction _loadRemoteModuleEntry() {\n  _loadRemoteModuleEntry = _asyncToGenerator(function* (remoteEntry) {\n    if (containerMap[remoteEntry]) {\n      return Promise.resolve();\n    }\n    return yield import( /* webpackIgnore:true */remoteEntry).then(container => {\n      initRemote(container, remoteEntry);\n      containerMap[remoteEntry] = container;\n    });\n  });\n  return _loadRemoteModuleEntry.apply(this, arguments);\n}\nfunction loadRemoteScriptEntry(_x8, _x9) {\n  return _loadRemoteScriptEntry.apply(this, arguments);\n}\nfunction _loadRemoteScriptEntry() {\n  _loadRemoteScriptEntry = _asyncToGenerator(function* (remoteEntry, remoteName) {\n    return new Promise((resolve, reject) => {\n      // Is remoteEntry already loaded?\n      if (containerMap[remoteName]) {\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = remoteEntry;\n      script.onerror = reject;\n      script.onload = () => {\n        const container = window[remoteName];\n        initRemote(container, remoteName);\n        containerMap[remoteName] = container;\n        resolve();\n      };\n      document.body.appendChild(script);\n    });\n  });\n  return _loadRemoteScriptEntry.apply(this, arguments);\n}\nfunction loadRemoteModule(_x10, _x11) {\n  return _loadRemoteModule.apply(this, arguments);\n}\nfunction _loadRemoteModule() {\n  _loadRemoteModule = _asyncToGenerator(function* (optionsOrRemoteName, exposedModule) {\n    let loadRemoteEntryOptions;\n    let key;\n    let remoteEntry;\n    let options;\n    if (typeof optionsOrRemoteName === 'string') {\n      options = {\n        type: 'manifest',\n        remoteName: optionsOrRemoteName,\n        exposedModule: exposedModule\n      };\n    } else {\n      options = optionsOrRemoteName;\n    }\n    // To support legacy API (< ng 13)\n    if (!options.type) {\n      const hasManifest = Object.keys(config).length > 0;\n      options.type = hasManifest ? 'manifest' : 'script';\n    }\n    if (options.type === 'manifest') {\n      const manifestEntry = config[options.remoteName];\n      if (!manifestEntry) {\n        throw new Error('Manifest does not contain ' + options.remoteName);\n      }\n      options = {\n        type: manifestEntry.type,\n        exposedModule: options.exposedModule,\n        remoteEntry: manifestEntry.remoteEntry,\n        remoteName: manifestEntry.type === 'script' ? options.remoteName : undefined\n      };\n      remoteEntry = manifestEntry.remoteEntry;\n    } else {\n      remoteEntry = options.remoteEntry;\n    }\n    if (options.type === 'script') {\n      loadRemoteEntryOptions = {\n        type: 'script',\n        remoteEntry: options.remoteEntry,\n        remoteName: options.remoteName\n      };\n      key = options.remoteName;\n    } else if (options.type === 'module') {\n      loadRemoteEntryOptions = {\n        type: 'module',\n        remoteEntry: options.remoteEntry\n      };\n      key = options.remoteEntry;\n    }\n    if (remoteEntry) {\n      yield loadRemoteEntry(loadRemoteEntryOptions);\n    }\n    return yield lookupExposedModule(key, options.exposedModule);\n  });\n  return _loadRemoteModule.apply(this, arguments);\n}\nfunction setManifest(_x12) {\n  return _setManifest.apply(this, arguments);\n}\nfunction _setManifest() {\n  _setManifest = _asyncToGenerator(function* (manifest, skipRemoteEntries = false) {\n    config = parseConfig(manifest);\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n  return _setManifest.apply(this, arguments);\n}\nfunction getManifest() {\n  return config;\n}\nfunction initFederation(_x13) {\n  return _initFederation.apply(this, arguments);\n}\nfunction _initFederation() {\n  _initFederation = _asyncToGenerator(function* (manifest, skipRemoteEntries = false) {\n    if (typeof manifest === 'string') {\n      return loadManifest(manifest, skipRemoteEntries);\n    } else {\n      return setManifest(manifest, skipRemoteEntries);\n    }\n  });\n  return _initFederation.apply(this, arguments);\n}\nfunction loadManifest(_x14) {\n  return _loadManifest.apply(this, arguments);\n}\nfunction _loadManifest() {\n  _loadManifest = _asyncToGenerator(function* (configFile, skipRemoteEntries = false) {\n    const result = yield fetch(configFile);\n    if (!result.ok) {\n      throw Error('could not load configFile: ' + configFile);\n    }\n    config = parseConfig(yield result.json());\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n  return _loadManifest.apply(this, arguments);\n}\nfunction parseConfig(config) {\n  const result = {};\n  for (const key in config) {\n    const value = config[key];\n    let entry;\n    if (typeof value === 'string') {\n      entry = {\n        remoteEntry: value,\n        type: 'module'\n      };\n    } else {\n      entry = {\n        ...value,\n        type: value.type || 'module'\n      };\n    }\n    result[key] = entry;\n  }\n  return result;\n}\nfunction loadRemoteEntries() {\n  return _loadRemoteEntries.apply(this, arguments);\n}\n/**\r\n * Generated bundle index. Do not edit.\r\n */\nfunction _loadRemoteEntries() {\n  _loadRemoteEntries = _asyncToGenerator(function* () {\n    const promises = [];\n    for (const key in config) {\n      const entry = config[key];\n      if (entry.type === 'module') {\n        promises.push(loadRemoteEntry({\n          type: 'module',\n          remoteEntry: entry.remoteEntry\n        }));\n      } else {\n        promises.push(loadRemoteEntry({\n          type: 'script',\n          remoteEntry: entry.remoteEntry,\n          remoteName: key\n        }));\n      }\n    }\n    yield Promise.all(promises);\n  });\n  return _loadRemoteEntries.apply(this, arguments);\n}\nexport { getManifest, initFederation, loadManifest, loadRemoteEntry, loadRemoteModule, setManifest };","map":{"version":3,"names":["config","containerMap","remoteMap","isDefaultScopeInitialized","lookupExposedModule","key","exposedModule","container","factory","get","Module","initRemote","__webpack_init_sharing__","init","__webpack_share_scopes__","default","loadRemoteEntry","remoteEntryOrOptions","remoteName","remoteEntry","loadRemoteScriptEntry","type","options","loadRemoteModuleEntry","Promise","resolve","then","reject","script","document","createElement","src","onerror","onload","window","body","appendChild","loadRemoteModule","optionsOrRemoteName","loadRemoteEntryOptions","hasManifest","Object","keys","length","manifestEntry","Error","undefined","setManifest","manifest","skipRemoteEntries","parseConfig","loadRemoteEntries","getManifest","initFederation","loadManifest","configFile","result","fetch","ok","json","value","entry","promises","push","all"],"sources":["/Users/jiss/Documents/Banco/shell-container/node_modules/@angular-architects/module-federation-runtime/fesm2020/angular-architects-module-federation-runtime.mjs"],"sourcesContent":["let config = {};\r\nconst containerMap = {};\r\nconst remoteMap = {};\r\nlet isDefaultScopeInitialized = false;\r\nasync function lookupExposedModule(key, exposedModule) {\r\n    const container = containerMap[key];\r\n    const factory = await container.get(exposedModule);\r\n    const Module = factory();\r\n    return Module;\r\n}\r\nasync function initRemote(container, key) {\r\n    // const container = window[key] as Container;\r\n    // Do we still need to initialize the remote?\r\n    if (remoteMap[key]) {\r\n        return container;\r\n    }\r\n    // Do we still need to initialize the share scope?\r\n    if (!isDefaultScopeInitialized) {\r\n        await __webpack_init_sharing__('default');\r\n        isDefaultScopeInitialized = true;\r\n    }\r\n    await container.init(__webpack_share_scopes__.default);\r\n    remoteMap[key] = true;\r\n    return container;\r\n}\r\nasync function loadRemoteEntry(remoteEntryOrOptions, remoteName) {\r\n    if (typeof remoteEntryOrOptions === 'string') {\r\n        const remoteEntry = remoteEntryOrOptions;\r\n        return await loadRemoteScriptEntry(remoteEntry, remoteName);\r\n    }\r\n    else if (remoteEntryOrOptions.type === 'script') {\r\n        const options = remoteEntryOrOptions;\r\n        return await loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\r\n    }\r\n    else if (remoteEntryOrOptions.type === 'module') {\r\n        const options = remoteEntryOrOptions;\r\n        await loadRemoteModuleEntry(options.remoteEntry);\r\n    }\r\n}\r\nasync function loadRemoteModuleEntry(remoteEntry) {\r\n    if (containerMap[remoteEntry]) {\r\n        return Promise.resolve();\r\n    }\r\n    return await import(/* webpackIgnore:true */ remoteEntry).then((container) => {\r\n        initRemote(container, remoteEntry);\r\n        containerMap[remoteEntry] = container;\r\n    });\r\n}\r\nasync function loadRemoteScriptEntry(remoteEntry, remoteName) {\r\n    return new Promise((resolve, reject) => {\r\n        // Is remoteEntry already loaded?\r\n        if (containerMap[remoteName]) {\r\n            resolve();\r\n            return;\r\n        }\r\n        const script = document.createElement('script');\r\n        script.src = remoteEntry;\r\n        script.onerror = reject;\r\n        script.onload = () => {\r\n            const container = window[remoteName];\r\n            initRemote(container, remoteName);\r\n            containerMap[remoteName] = container;\r\n            resolve();\r\n        };\r\n        document.body.appendChild(script);\r\n    });\r\n}\r\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\r\n    let loadRemoteEntryOptions;\r\n    let key;\r\n    let remoteEntry;\r\n    let options;\r\n    if (typeof optionsOrRemoteName === 'string') {\r\n        options = {\r\n            type: 'manifest',\r\n            remoteName: optionsOrRemoteName,\r\n            exposedModule: exposedModule\r\n        };\r\n    }\r\n    else {\r\n        options = optionsOrRemoteName;\r\n    }\r\n    // To support legacy API (< ng 13)\r\n    if (!options.type) {\r\n        const hasManifest = Object.keys(config).length > 0;\r\n        options.type = hasManifest ? 'manifest' : 'script';\r\n    }\r\n    if (options.type === 'manifest') {\r\n        const manifestEntry = config[options.remoteName];\r\n        if (!manifestEntry) {\r\n            throw new Error('Manifest does not contain ' + options.remoteName);\r\n        }\r\n        options = {\r\n            type: manifestEntry.type,\r\n            exposedModule: options.exposedModule,\r\n            remoteEntry: manifestEntry.remoteEntry,\r\n            remoteName: manifestEntry.type === 'script' ? options.remoteName : undefined,\r\n        };\r\n        remoteEntry = manifestEntry.remoteEntry;\r\n    }\r\n    else {\r\n        remoteEntry = options.remoteEntry;\r\n    }\r\n    if (options.type === 'script') {\r\n        loadRemoteEntryOptions = {\r\n            type: 'script',\r\n            remoteEntry: options.remoteEntry,\r\n            remoteName: options.remoteName,\r\n        };\r\n        key = options.remoteName;\r\n    }\r\n    else if (options.type === 'module') {\r\n        loadRemoteEntryOptions = {\r\n            type: 'module',\r\n            remoteEntry: options.remoteEntry,\r\n        };\r\n        key = options.remoteEntry;\r\n    }\r\n    if (remoteEntry) {\r\n        await loadRemoteEntry(loadRemoteEntryOptions);\r\n    }\r\n    return await lookupExposedModule(key, options.exposedModule);\r\n}\r\nasync function setManifest(manifest, skipRemoteEntries = false) {\r\n    config = parseConfig(manifest);\r\n    if (!skipRemoteEntries) {\r\n        await loadRemoteEntries();\r\n    }\r\n}\r\nfunction getManifest() {\r\n    return config;\r\n}\r\nasync function initFederation(manifest, skipRemoteEntries = false) {\r\n    if (typeof manifest === 'string') {\r\n        return loadManifest(manifest, skipRemoteEntries);\r\n    }\r\n    else {\r\n        return setManifest(manifest, skipRemoteEntries);\r\n    }\r\n}\r\nasync function loadManifest(configFile, skipRemoteEntries = false) {\r\n    const result = await fetch(configFile);\r\n    if (!result.ok) {\r\n        throw Error('could not load configFile: ' + configFile);\r\n    }\r\n    config = parseConfig(await result.json());\r\n    if (!skipRemoteEntries) {\r\n        await loadRemoteEntries();\r\n    }\r\n}\r\nfunction parseConfig(config) {\r\n    const result = {};\r\n    for (const key in config) {\r\n        const value = config[key];\r\n        let entry;\r\n        if (typeof value === 'string') {\r\n            entry = {\r\n                remoteEntry: value,\r\n                type: 'module',\r\n            };\r\n        }\r\n        else {\r\n            entry = {\r\n                ...value,\r\n                type: value.type || 'module',\r\n            };\r\n        }\r\n        result[key] = entry;\r\n    }\r\n    return result;\r\n}\r\nasync function loadRemoteEntries() {\r\n    const promises = [];\r\n    for (const key in config) {\r\n        const entry = config[key];\r\n        if (entry.type === 'module') {\r\n            promises.push(loadRemoteEntry({ type: 'module', remoteEntry: entry.remoteEntry }));\r\n        }\r\n        else {\r\n            promises.push(loadRemoteEntry({\r\n                type: 'script',\r\n                remoteEntry: entry.remoteEntry,\r\n                remoteName: key,\r\n            }));\r\n        }\r\n    }\r\n    await Promise.all(promises);\r\n}\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { getManifest, initFederation, loadManifest, loadRemoteEntry, loadRemoteModule, setManifest };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}